# 8-Puzzle Solver: A* and Iterative Deepening Search (IDS)

This repository contains two implementations for solving the **8-puzzle** problem: one using the **A* (A-star)** search algorithm and another using **Iterative Deepening Search (IDS)**. These algorithms are implemented in C++ and demonstrate different approaches to finding the optimal solution for this classic problem.

## Problem Description

The 8-puzzle is a sliding puzzle consisting of a 3x3 grid with eight numbered tiles and one empty space. The objective is to move the tiles to match a **goal state**, typically ordered as follows:

```
1 2 3
8 0 4
7 6 5
```

### Initial State
The initial configuration of the puzzle can be defined by the user. For the examples in these implementations, the puzzle starts as:

```
2 8 3
1 6 4
7 0 5
```

### Goal State
The goal configuration is:

```
1 2 3
8 0 4
7 6 5
```

## Algorithms Implemented

### 1. A* (A-star) Search
A* is an informed search algorithm that uses a **heuristic function** to guide the search. It explores paths based on their total cost \( f(n) = g(n) + h(n) \), where:
- \( g(n) \): Cost from the start to the current node.
- \( h(n) \): Estimated cost from the current node to the goal (Manhattan Distance in this implementation).

The A* algorithm ensures the optimal solution if the heuristic is admissible (i.e., never overestimates the true cost).

#### Key Features:
- **Heuristic Function**: Manhattan distance.
- **Search Space**: Explores states until the goal is reached.
- **Output**: Prints the solution path and the number of nodes expanded.

### 2. Iterative Deepening Search (IDS)
IDS is an uninformed search algorithm that combines the depth-first search (DFS) strategy with iterative deepening. It progressively increases the depth limit, exploring all nodes at each depth before increasing the limit.

#### Key Features:
- **Uninformed Search**: Does not use heuristics.
- **Depth-Limited Search**: Explores states up to a specified depth.
- **Output**: Prints the solution path and the number of nodes expanded.

## Code Structure

### Common Components
- **Puzzle Representation**: The puzzle state is represented as a 1D vector of integers, with `0` representing the empty tile.
- **Goal Check**: A function checks if the current state matches the goal state.
- **Move Generation**: Valid moves are generated by swapping the empty tile with adjacent tiles.

### A* Code Walkthrough
1. **Heuristic Calculation**:
   ```cpp
   int calculateHeuristic(const vector<int>& state);
   ```
   Computes the Manhattan distance for the given state.

2. **Priority Queue**:
   Uses a `priority_queue` to manage states, prioritized by \( f(n) = g(n) + h(n) \).

3. **Search Logic**:
   ```cpp
   void solvePuzzleAStar(const vector<int>& initial_state);
   ```
   Implements the A* search, expanding states until the goal is found or the queue is empty.

### IDS Code Walkthrough
1. **Depth-Limited Search (DLS)**:
   ```cpp
   bool DLS(vector<int> state, int empty_index, int depth_limit, vector<vector<int>>& path, int& nodesExpanded);
   ```
   Explores states up to a given depth limit.

2. **Iterative Deepening**:
   ```cpp
   bool IDS(vector<int> initial_state, int initial_empty_index, int max_depth, vector<vector<int>>& path, int& nodesExpanded);
   ```
   Calls `DLS` iteratively, increasing the depth limit on each iteration.

## How to Run

1. **Compile the Code**:
   Use a C++ compiler to compile the respective implementation. For example:
   ```bash
   g++ AStar.cpp -o AStar
   g++ IDS.cpp -o IDS
   ```

2. **Run the Program**:
   Execute the compiled program:
   ```bash
   ./AStar
   ./IDS
   ```

3. **Output**:
   Both programs will:
   - Print the solution path step by step.
   - Display the number of nodes expanded during the search.

## Example Output

### A* Output:
```
Initial puzzle state:

2 8 3
1 6 4
7 0 5

Solution found (A*)!
Number of nodes expanded: 10

1 2 3
8 0 4
7 6 5
----
```

### IDS Output:
```
Initial puzzle state:

2 8 3
1 6 4
7 0 5

Solution found!
Number of nodes expanded: 15

1 2 3
8 0 4
7 6 5
----
```

## Comparison of A* and IDS

| Metric              | A*                            | IDS                          |
|---------------------|-------------------------------|------------------------------|
| **Type**            | Informed                     | Uninformed                   |
| **Heuristic**       | Uses Manhattan Distance       | None                         |
| **Performance**     | Typically faster             | Slower for large depths      |
| **Memory Usage**    | Higher (stores all nodes)     | Lower (DFS-like memory)      |
| **Optimality**      | Yes (admissible heuristic)    | Yes                          |

## Conclusion

Both A* and IDS solve the 8-puzzle problem, each with distinct advantages and trade-offs. A* excels in efficiency due to its heuristic, while IDS provides a memory-efficient alternative. Experiment with both to understand their nuances and practical applications.